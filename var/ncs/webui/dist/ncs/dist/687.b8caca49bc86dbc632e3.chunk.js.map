{"version":3,"file":"687.b8caca49bc86dbc632e3.chunk.js","mappings":"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","sources":["webpack://webui/./src/modules/nodes/thunks.js","webpack://webui/./src/modules/schemas/actions.js"],"sourcesContent":["import jsonrpcSimple, {\n    create as _create,\n    deleteNode as _deleteNode,\n    deleteNodes as _deleteNodes,\n    exists as _exists,\n    getCase as _getCase,\n    load as _load,\n} from '@webui-one/core/jsonrpc';\n\nimport {\n    getLeafName,\n    getParentPath,\n} from '@webui-one/core/utils/path';\nimport {\n    pathToObjects,\n} from '@webui-one/core/keypath/kp-parser';\n\nimport {\n    getSchema as _getSchema,\n} from 'modules/schemas/actions';\n\nimport {\n    reEvaluateSchemaThunk as _reEvaluateSchemaThunk,\n} from 'modules/schemas/thunks';\n\nimport {\n    read as _readThunk,\n    write as _writeThunk,\n} from 'modules/transactions/actions';\n\nimport {\n    createAction,\n    createErrorAction,\n    deleteAction,\n    deletePathsAction,\n    deleteErrorAction,\n    deleteNodeAndChildrenAction,\n    deleteStartAction,\n    deleteCompleteAction,\n    existsAction,\n    existsErrorAction,\n    existsPendingAction,\n    getCaseStartAction,\n    getCaseCompleteAction,\n    getCaseErrorAction,\n    getValueAction,\n    getValueErrorAction,\n    getValuePendingAction,\n    setCaseCompleteAction,\n    setValueAction,\n    setValueErrorAction,\n    setValueInterruptAction,\n    setValueStartAction,\n} from './actions';\n\nimport { selectNode } from './selectors';\n\nexport const existsThunk = ({\n    exists,\n    path,\n    isActionInput,\n    existsPath,\n    funcs: {\n        readThunk = _readThunk,\n        existsFunc = _exists,\n    } = {},\n} = {}) => async (dispatch) => {\n    if (isActionInput) {\n        await dispatch(existsAction(path, { exists }));\n        return Promise.resolve(undefined);\n    }\n\n    dispatch(existsPendingAction(existsPath || path));\n\n    try {\n        const { th } = await dispatch(readThunk({ path }));\n        const res = await existsFunc({ th, path: existsPath || path });\n        return dispatch(existsAction(path, res));\n    } catch (error) {\n        return dispatch(existsErrorAction(path, error));\n    }\n};\n\nexport const internalCreateThunk = ({\n    path,\n    data,\n    funcs: {\n        create = _create,\n        load = _load,\n        writeThunk = _writeThunk,\n    } = {},\n} = {}) => async (dispatch) => {\n    try {\n        const { th } = await dispatch(writeThunk({ path }));\n        await create({ th, path, data });\n        if (data) {\n            await load({ th, path, data, format: 'json' });\n        }\n        return dispatch(createAction(path, data));\n    } catch (error) {\n        return dispatch(createErrorAction(path, error));\n    }\n};\n\nexport const createAllowExistsThunk = ({\n    path,\n    data,\n    funcs: {\n        exists = existsThunk,\n        create = internalCreateThunk,\n    } = {},\n} = {}) => async (dispatch) => {\n    const res = await dispatch(exists({ path }));\n    if (!res.exists) {\n        return dispatch(create({ path, data }));\n    }\n    return Promise.resolve();\n};\n\nexport const createDisallowExistsThunk = ({\n    path,\n    data,\n    funcs: {\n        create = internalCreateThunk,\n        existsFunc = _exists,\n        readThunk = _readThunk,\n    } = {},\n} = {}) => async (dispatch) => {\n    try {\n        const { th } = await dispatch(readThunk({ path }));\n        const res = await existsFunc({ th, path });\n        if (!res.exists) {\n            return dispatch(create({ path, data }));\n        }\n        return { error: `The element ${path} already exists.` };\n    } catch (error) {\n        return { error: error.message };\n    }\n};\n\nexport const createThunk = ({\n    caseAncestors,\n    dependants,\n    path,\n    data,\n    funcs: {\n        createAllowExists = createAllowExistsThunk,\n        reEvaluateSchemaThunk = _reEvaluateSchemaThunk,\n    } = {},\n} = {}) => async (dispatch) => {\n    await dispatch(createAllowExists({ path, data }));\n\n    if (dependants) {\n        await dispatch(reEvaluateSchemaThunk(dependants));\n    }\n\n    if (caseAncestors) {\n        caseAncestors.forEach(ca => (\n            dispatch(setCaseCompleteAction(getParentPath(ca), getLeafName(ca)))\n        ));\n    }\n};\n\nexport const deleteNodeThunk = ({\n    path,\n    deleteChildren,\n    funcs: {\n        deleteNode = _deleteNode,\n        writeThunk = _writeThunk,\n    } = {},\n} = {}) => async (dispatch) => {\n    try {\n        const { th } = await dispatch(writeThunk({ path }));\n        const res = await deleteNode({ th, path });\n        if (res && res.warnings) throw new Error(res.warnings.join(' '));\n        if (!deleteChildren) return dispatch(deleteAction(path));\n        return dispatch(deleteNodeAndChildrenAction(path));\n    } catch (error) {\n        return dispatch(deleteErrorAction(path, error));\n    }\n};\n\nexport const deletePathsThunk = ({\n    path,\n    paths,\n    isActionInput,\n    funcs: {\n        deleteNodes = _deleteNodes,\n        writeThunk = _writeThunk,\n    } = {},\n} = {}) => async (dispatch, getState) => { // eslint-disable-line consistent-return\n    try {\n        let th;\n        if (isActionInput) {\n            const trans = await getState().transactions.trans;\n            th = pathToObjects(path).reduce((acc, obj) => {\n                const currPath = obj.path;\n                const actionTransIx = Object.keys(trans).find(ix => (\n                    trans[ix].actionPath === currPath\n                ));\n                return actionTransIx !== undefined\n                    ? trans[actionTransIx].th\n                    : acc;\n            }, undefined);\n        }\n\n        if (th === undefined) {\n            const response = await dispatch(writeThunk({ path }));\n            th = response.th;\n        }\n\n        const result = await deleteNodes({ th, paths });\n\n        const warnings = result.reduce((acc, curr) => {\n            if (curr.warnings) acc.push(curr.warnings);\n            return acc;\n        }, []);\n        const success = result.reduce((acc, curr, ix) => {\n            if (!curr.warnings) acc.push(paths[ix]);\n            return acc;\n        }, []);\n\n        if (warnings.length > 0) {\n            if (success.length > 0) {\n                dispatch(deletePathsAction(success));\n            }\n            throw new Error(warnings.join(' '));\n        }\n\n        return dispatch(deletePathsAction(success));\n    } catch (error) {\n        return dispatch(deleteErrorAction(path, error));\n    }\n};\n\nexport const deleteNodesThunk = ({\n    dependants,\n    isActionInput,\n    path,\n    paths,\n    loadingPath,\n    funcs: {\n        reEvaluateSchemaThunk = _reEvaluateSchemaThunk,\n    } = {},\n} = {}) => async (dispatch) => {\n    dispatch(deleteStartAction(loadingPath));\n    const result = await dispatch(deletePathsThunk({ path, paths, isActionInput }));\n    dispatch(deleteCompleteAction(loadingPath));\n    if (dependants) {\n        dispatch(reEvaluateSchemaThunk(dependants));\n    }\n    return result;\n};\n\nexport const deleteLocalNodesThunk = ({\n    paths,\n} = {}) => dispatch => (\n    Promise.all(\n        paths.map(path => dispatch(deleteAction(path))),\n    )\n);\n\nexport const deleteAllowNonExistsThunk = ({\n    path,\n    deleteChildren,\n    funcs: {\n        exists = existsThunk,\n        deleteNode = deleteNodeThunk,\n    } = {},\n} = {}) => async (dispatch) => {\n    const res = await dispatch(exists({ path }));\n    if (res.exists) return dispatch(deleteNode({ path, deleteChildren }));\n    return Promise.resolve();\n};\n\nexport const deleteThunk = ({\n    caseAncestors,\n    deleteChildren,\n    dependants,\n    path,\n    funcs: {\n        reEvaluateSchemaThunk = _reEvaluateSchemaThunk,\n        deleteAllowNonExists = deleteAllowNonExistsThunk,\n    } = {},\n} = {}) => async (dispatch) => {\n    dispatch(deleteStartAction(path));\n    await dispatch(deleteAllowNonExists({ path, deleteChildren }));\n\n    if (dependants) {\n        await dispatch(reEvaluateSchemaThunk(dependants));\n    }\n\n    if (caseAncestors) {\n        caseAncestors.forEach(ca => (\n            dispatch(setCaseCompleteAction(getParentPath(ca), getLeafName(ca)))\n        ));\n    }\n    dispatch(deleteCompleteAction(path));\n};\n\nconst parentPath = path => path.substring(0, path.lastIndexOf('/'));\n\nexport const getCaseThunk = ({\n    schemapath,\n    nodepath,\n    choice,\n    funcs: {\n        getCase = _getCase,\n        readThunk = _readThunk,\n    } = {},\n} = {}) => (\n    async (dispatch) => {\n        const path = parentPath(nodepath || schemapath);\n        const choicePath = `${path}/${choice}`;\n        dispatch(getCaseStartAction(choicePath));\n        try {\n            const { th } = await dispatch(readThunk({ path }));\n            const result = await getCase({ th, path, choice });\n            return dispatch(getCaseCompleteAction(choicePath, result.case));\n        } catch (error) {\n            return dispatch(getCaseErrorAction(choicePath, error));\n        }\n    }\n);\n\nfunction getValueInternal(\n    path,\n    {\n        funcs: {\n            jsonrpc = jsonrpcSimple,\n            readThunk = _readThunk,\n        } = {},\n    } = {},\n) {\n    return (dispatch) => {\n        dispatch(getValuePendingAction(path));\n        return dispatch(readThunk({ path })).then(({ th }) => (\n            jsonrpc('get_value', { th, path }).then(result => (\n                dispatch(getValueAction(path, result.value))\n            ))\n        )).catch((error) => {\n            if (error.type === 'data.not_found') {\n                dispatch(getValueAction(path, undefined));\n            } else {\n                dispatch(getValueErrorAction(path, error));\n            }\n        });\n    };\n}\n\nfunction getValueCachedInternal(\n    path,\n    isConfigFalseCallpoint,\n    {\n        funcs: {\n            getValue = getValueInternal,\n        } = {},\n    } = {},\n) {\n    return (dispatch, getState) => {\n        const node = selectNode(getState(), path);\n        if (!isConfigFalseCallpoint && Object.keys(node).indexOf('value') > -1 && !node.isDeleted) {\n            return Promise.resolve(dispatch(getValueAction(path, node.value)));\n        }\n\n        return dispatch(getValue(path));\n    };\n}\n\nconst getValueThunkInternal = ({\n    isConfigFalseCallpoint,\n    path,\n    funcs: {\n        getValueCached = getValueCachedInternal,\n    } = {},\n} = {}) => async (dispatch) => {\n    await dispatch(getValueCached(path, isConfigFalseCallpoint));\n};\n\nexport const setCaseThunk = ({\n    path,\n    parentNodepath,\n    value,\n    funcs: {\n        getSchema = _getSchema,\n    } = {},\n} = {}) => async (dispatch) => {\n    await dispatch(getSchema({ path: parentNodepath }));\n    await dispatch(setCaseCompleteAction(path, value));\n};\n\nfunction setValueInternal(\n    path,\n    value,\n    {\n        funcs: {\n            jsonrpc = jsonrpcSimple,\n            writeThunk = _writeThunk,\n        } = {},\n    } = {},\n) {\n    return (dispatch) => {\n        dispatch(setValueStartAction(path, value));\n        return dispatch(writeThunk({ path })).then(({ th }) =>\n            jsonrpc('set_value', { th, path, value }).then(() =>\n                dispatch(setValueAction(path, value)),\n            ).catch((error) => {\n                if (error && error.data && error.data.reason === '\"\" is not a valid value.') {\n                    dispatch(deleteThunk({ caseAncestors: null, dependants: null, path }));\n                    dispatch(setValueInterruptAction(path));\n                } else {\n                    dispatch(setValueErrorAction(path, value, error));\n                }\n            },\n            ),\n        );\n    };\n}\n\nexport const setValueThunk = ({\n    caseAncestors,\n    dependants,\n    path,\n    value,\n    funcs: {\n        reEvaluateSchemaThunk = _reEvaluateSchemaThunk,\n        setValue = setValueInternal,\n    } = {},\n} = {}) => async (dispatch) => {\n    await dispatch(setValue(path, value));\n\n    if (dependants) {\n        await dispatch(reEvaluateSchemaThunk(dependants));\n    }\n\n    if (caseAncestors) {\n        caseAncestors.forEach(ca => (\n            dispatch(setCaseCompleteAction(getParentPath(ca), getLeafName(ca)))\n        ));\n    }\n};\n\nexport {\n    getValueInternal as getValue,\n    getValueCachedInternal as getValueCached,\n    getValueThunkInternal as getValueThunk,\n    setValueInternal as setValue,\n};\n","import { getSchema as _getSchema2 } from 'modules/schemas2/actions';\nimport * as actionTypes from './actionTypes';\n\nexport const getSchemaCompleteAction = (path, schema, queryPath) => ({\n    type: actionTypes.GET_SCHEMA_COMPLETE,\n    path,\n    schema,\n    queryPath,\n});\n\nexport const getSchemaErrorAction = (path, error) => ({\n    type: actionTypes.GET_SCHEMA_ERROR,\n    path,\n    error,\n});\n\nexport const getSchemaStartAction = (path, reload) => ({\n    type: actionTypes.GET_SCHEMA_START,\n    path,\n    reload,\n});\n\nexport const getSchema = ({\n    path,\n    params,\n    reload,\n    funcs: {\n        getSchema2 = _getSchema2,\n    } = {},\n} = {}) => getSchema2({ path, reload, params });\n"],"names":["existsThunk","exists","path","isActionInput","existsPath","funcs","readThunk","_readThunk","existsFunc","_exists","async","dispatch","existsAction","Promise","resolve","undefined","existsPendingAction","th","res","error","existsErrorAction","internalCreateThunk","data","create","_create","load","_load","writeThunk","_writeThunk","format","createAction","createErrorAction","createAllowExistsThunk","message","caseAncestors","dependants","createAllowExists","reEvaluateSchemaThunk","_reEvaluateSchemaThunk","forEach","ca","setCaseCompleteAction","getParentPath","getLeafName","deleteNodeThunk","deleteChildren","deleteNode","_deleteNode","warnings","Error","join","deleteNodeAndChildrenAction","deleteAction","deleteErrorAction","deletePathsThunk","paths","deleteNodes","_deleteNodes","getState","trans","transactions","pathToObjects","reduce","acc","obj","currPath","actionTransIx","Object","keys","find","ix","actionPath","result","curr","push","success","length","deletePathsAction","loadingPath","deleteStartAction","deleteCompleteAction","all","map","deleteAllowNonExistsThunk","deleteThunk","deleteAllowNonExists","parentPath","substring","lastIndexOf","getValueInternal","jsonrpc","jsonrpcSimple","getValuePendingAction","then","getValueAction","value","catch","type","getValueErrorAction","getValueCachedInternal","isConfigFalseCallpoint","getValue","node","selectNode","indexOf","isDeleted","setValueInternal","setValueStartAction","setValueAction","reason","setValueInterruptAction","setValueErrorAction","schemapath","nodepath","choice","getCase","_getCase","choicePath","getCaseStartAction","getCaseCompleteAction","case","getCaseErrorAction","getValueCached","parentNodepath","getSchema","_getSchema","setValue","schema","queryPath","actionTypes","GET_SCHEMA_COMPLETE","GET_SCHEMA_ERROR","reload","GET_SCHEMA_START","params","getSchema2","_getSchema2"],"sourceRoot":""}